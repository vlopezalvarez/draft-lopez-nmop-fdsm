



Network Working Group                                        D. R. Lopez
Internet-Draft                                                Telefonica
Intended status: Informational                                  V. Lopez
Expires: 28 April 2025                                             Nokia
                                                         25 October 2024


                  Formal definition of state machines
                      draft-nmop-lopez-fdsm-latest

Abstract

   This document defines a formal approach for representing state
   machines in a standardized manner.  It specifies the structure and
   methodology for modeling not just states, but also transitions, and
   events, aiming to create a consistent framework for use across
   diverse domains.  The goal is to improve clarity, interoperability,
   and reusability of state machine definitions.

About This Document

   This note is to be removed before publishing as an RFC.

   The latest revision of this draft can be found at
   https://vlopezalvarez.github.io/draft-lopez-nmop-fdsm/draft-nmop-
   lopez-fdsm.html.  Status information for this document may be found
   at https://datatracker.ietf.org/doc/draft-nmop-lopez-fdsm/.

   Source for this draft and an issue tracker can be found at
   https://github.com/vlopezalvarez/draft-lopez-nmop-fdsm.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 28 April 2025.

Copyright Notice

   Copyright (c) 2024 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Revised BSD License text as
   described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Revised BSD License.

Table of Contents

   1.  Introduction
     1.1.  Requirements Language
   2.  Use Cases
     2.1.  Code generation
     2.2.  API benchmarking
   3.  Security Considerations
   4.  IANA Considerations
   5.  References
     5.1.  Normative References
     5.2.  Informative References
   Acknowledgments
   Authors' Addresses

1.  Introduction

   State machines play a fundamental role in the formal description of
   network protocols, and many IETF RFCs have employed them to define
   protocol operations.  These state machines serve to illustrate how a
   system transitions between various states, helping to clarify complex
   behaviors and enabling systems collaboration.  By using state
   machines, RFCs can effectively describe how protocols handle
   different operational scenarios, such as error handling, session
   management, or negotiation processes.

   However, there is no standardized method for describing state
   machines across RFCs.  The current practice varies, with state
   machines often presented through informal diagrams or simple
   enumerations of states and transitions.  This lack of consistency
   introduces ambiguity, making it harder to interpret or compare the
   behavior of state machines across different protocols.  Furthermore,
   the absence of a formal structure makes it difficult
   interoperability, forcing developers to read diagrams leading into
   misinterpretation.

   There has been some previous work in IETF, [RFC2360] proposes three
   methods to represent state machines:

   *  State Transition Diagrams: Represent protocol states as boxes
      connected by arcs, with transitions labeled by the events that
      trigger them and actions noted in parentheses.  This method is
      ideal for simple visualizations, limited by ASCII format
      constraints.

   *  State Transition Tables: Display events vertically and states
      horizontally, with transitions represented as "action/new state"
      pairs.  Multiple actions are separated by commas, and this format
      efficiently summarizes complex transitions.  The preferred
      approach lists the new state after the action (as seen in
      [RFC1661]).

   *  Time Line Diagrams: Depict interactions between two machines, with
      states shown along the outside and actions triggering transitions
      within the time line.  Time flows downward, showing state changes
      as events occur in sequence.

   Another attemp was the discussion in IETF 86 in the Finite State
   Machine group.  A summary of the conclusions from the Finite State
   Machine meeting at IETF 68 based on the minutes:

   *  Need for Formal State Machine Language: There was a general
      consensus that a formal state machine language would be
      beneficial, especially for professional protocol developers and
      for use in RFCs.  However, it should not be a mandatory
      requirement for all IETF specifications, as this could place
      unnecessary burdens on open-source or hobbyist developers.

   *  Existing Tools vs. New Solutions: Some attendees, such as Aaron
      Silverton, suggested adopting existing formal languages like ITU-
      T's SDL or UML, while others, including Stephane Bortzmeyer,
      advocated for developing a simpler, IETF-specific tool like
      Cosmogol.  It was recognized that existing tools can be complex,
      and a balance between simplicity and expressiveness would be
      important.

   *  Experimentation and Future Steps: There was agreement that an
      experiment with a formal state machine language, like Cosmogol,
      should be conducted to validate the approach rather than
      immediately focusing on choosing or developing a specific
      language.  The importance of simplicity and community adoption was
      highlighted, and there was no immediate decision to form a formal
      working group, with the suggestion to continue discussions on the
      mailing list.

   *  The overall takeaway was that while formalizing state machine
      descriptions is seen as valuable, the IETF should proceed
      cautiously to avoid unnecessary complexity and ensure broad
      community support.

   Finally, [I-D.draft-sambo-netmod-yang-fsm] introduces a formal method
   for defining finite state machines (FSMs) within YANG models.  The
   work extended the YANG data modeling language by allowing protocol
   state machines to be formally represented and integrated into network
   management and configuration systems.

   Authors believe that there is a need for a formal definition of state
   machines that goes beyond mere enumeration.  A formal approach would
   not only provide a clear representation of states but would also
   define transitions, events triggering transitions, and how
   condittions transitioning between different states.  Such a
   standardized framework would improve interoperability and
   understanding, allowing for more precise and reusable state machine
   descriptions in IETF specifications.

1.1.  Requirements Language

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   [RFC2119], [RFC8174] when, and only when, they appear in all
   capitals, as shown here.

2.  Use Cases

2.1.  Code generation

   YANG models are widely used to describe data structures and
   operations in a machine-readable format, enabling the automatic
   generation of client code for application integration.  This
   significantly reduces the development effort by providing ready-made,
   standardized client libraries for interacting with various systems.
   However, when state machines are not formally described within these
   models, this advantage is diminished.  In current practice, state
   machines are often represented informally through text, diagrams, or
   enumerations.

   This situation forces to have human interpretation to understand the
   transitions and behaviors, and manual coding to reflect them in
   software.  The absence of a formal definition for state machines
   breaks the automation pipeline, making it impossible to automatically
   generate code that handles state transitions.  A formalized state
   machine definition would preserve the value of autogeneration,
   ensuring that the system behaviors, as well as data structures, can
   be automatically translated into executable code.

2.2.  API benchmarking

   System and network operators often request support for YANG models in
   API development, as these models enable better management and
   interaction with network elements through standardized APIs.  One key
   aspect of API design is ensuring that the systemâ€™s stateful
   behaviors, such as session management or configuration operations,
   are accurately modeled and tested.

   A formal description of state machines would allow for automated
   testing of API transitions between states.  Instead of manually
   verifying how an API responds to various state changes, a formal
   model could be used to automatically generate tests that verify the
   correct implementation of transitions.  This would not only improve
   the efficiency of API development and benchmarking but also ensure
   more robust implementations by reducing the chances of human error
   during manual test creation.

3.  Security Considerations

   TODO Security

4.  IANA Considerations

   This document has no IANA actions.

5.  References

5.1.  Normative References

   [I-D.draft-sambo-netmod-yang-fsm]
              Sambo, N., Castoldi, P., Fioccola, G., Cugini, F., Song,
              H., and T. Zhou, "YANG model for finite state machine",
              Work in Progress, Internet-Draft, draft-sambo-netmod-yang-
              fsm-05, 21 May 2019,
              <https://datatracker.ietf.org/doc/html/draft-sambo-netmod-
              yang-fsm-05>.

   [RFC1661]  Simpson, W., Ed., "The Point-to-Point Protocol (PPP)",
              STD 51, RFC 1661, DOI 10.17487/RFC1661, July 1994,
              <https://www.rfc-editor.org/rfc/rfc1661>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/rfc/rfc2119>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/rfc/rfc8174>.

5.2.  Informative References

   [RFC2360]  Scott, G., "Guide for Internet Standards Writers", BCP 22,
              RFC 2360, DOI 10.17487/RFC2360, June 1998,
              <https://www.rfc-editor.org/rfc/rfc2360>.

Acknowledgments

   TODO acknowledge.

Authors' Addresses

   Diego R. Lopez
   Telefonica
   Email: diego.r.lopez@telefonica.com


   Victor Lopez
   Nokia
   Email: victor.lopez@nokia.com
